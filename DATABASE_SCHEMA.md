# Database Schema Documentation

Complete database schema documentation for the mech-auth authentication system.

## Overview

The mech-auth database schema consists of 4 tables designed to support:
- Email/password authentication
- OAuth authentication (GitHub, Google)
- Session management with expiration
- Email verification flow
- Password reset flow

**Database**: PostgreSQL 14+
**Access Method**: Mech Storage HTTP API
**Query Builder**: Kysely (type-safe SQL)

## Entity-Relationship Diagram

```
┌─────────────────────────────────────────────────┐
│                     users                       │
│─────────────────────────────────────────────────│
│ id (UUID, PK)                                   │
│ email (TEXT, UNIQUE, NOT NULL)                  │
│ email_verified (BOOLEAN, DEFAULT FALSE)         │
│ password_hash (TEXT, NULL)                      │
│ github_id (TEXT, UNIQUE, NULL)                  │
│ google_id (TEXT, UNIQUE, NULL)                  │
│ name (TEXT, NULL)                               │
│ avatar_url (TEXT, NULL)                         │
│ created_at (TIMESTAMPTZ, DEFAULT NOW())         │
│ updated_at (TIMESTAMPTZ, AUTO-UPDATE)           │
└─────────────────────────────────────────────────┘
           │                  │                 │
           │                  │                 │
           │ ON DELETE        │                 │ ON DELETE
           │ CASCADE          │ ON DELETE       │ CASCADE
           │                  │ CASCADE         │
           ▼                  ▼                 ▼
┌──────────────────┐  ┌─────────────────────┐  ┌────────────────────────┐
│    sessions      │  │ email_verification_ │  │ password_reset_tokens  │
│                  │  │      tokens         │  │                        │
│──────────────────│  │─────────────────────│  │────────────────────────│
│ id (TEXT, PK)    │  │ token (TEXT, PK)    │  │ token (TEXT, PK)       │
│ user_id (UUID)   │  │ user_id (UUID)      │  │ user_id (UUID)         │
│ expires_at (TS)  │  │ email (TEXT)        │  │ expires_at (TS)        │
│ ip_address (TEXT)│  │ expires_at (TS)     │  │ created_at (TS)        │
│ user_agent (TEXT)│  │ created_at (TS)     │  └────────────────────────┘
│ created_at (TS)  │  └─────────────────────┘
└──────────────────┘

Legend:
PK = Primary Key
TS = TIMESTAMPTZ (timestamp with timezone)
```

## Tables

### 1. users

**Purpose**: Core users table supporting multiple authentication methods.

**Columns**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique user identifier |
| `email` | TEXT | UNIQUE, NOT NULL | User email address |
| `email_verified` | BOOLEAN | DEFAULT FALSE | Whether email has been verified |
| `password_hash` | TEXT | NULL | Bcrypt hashed password (NULL for OAuth-only users) |
| `github_id` | TEXT | UNIQUE, NULL | GitHub OAuth user ID |
| `google_id` | TEXT | UNIQUE, NULL | Google OAuth user ID |
| `name` | TEXT | NULL | User display name |
| `avatar_url` | TEXT | NULL | URL to user avatar image |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | User creation timestamp |
| `updated_at` | TIMESTAMPTZ | DEFAULT NOW() | Last update timestamp (auto-updated via trigger) |

**Indexes**:
- `idx_users_email` (email) - Fast email lookup for login
- `idx_users_github_id` (github_id) WHERE github_id IS NOT NULL - OAuth user lookup (partial)
- `idx_users_google_id` (google_id) WHERE google_id IS NOT NULL - OAuth user lookup (partial)

**Constraints**:
- `users_auth_method_check`: Ensures at least one authentication method exists
  ```sql
  CHECK (password_hash IS NOT NULL OR github_id IS NOT NULL OR google_id IS NOT NULL)
  ```

**Triggers**:
- `update_users_updated_at`: Automatically updates `updated_at` on row modification

**Authentication Methods**:
1. **Email/Password**: `email` + `password_hash` set
2. **GitHub OAuth**: `email` + `github_id` set, `password_hash` NULL
3. **Google OAuth**: `email` + `google_id` set, `password_hash` NULL
4. **Hybrid**: User can link multiple OAuth providers to one account

---

### 2. sessions

**Purpose**: Session management with expiration tracking. Supports session invalidation and security monitoring.

**Columns**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Random session ID (generated by Oslo) |
| `user_id` | UUID | REFERENCES users(id) ON DELETE CASCADE | User who owns this session |
| `expires_at` | TIMESTAMPTZ | NOT NULL | Session expiration timestamp |
| `ip_address` | TEXT | NULL | Client IP address (for security monitoring) |
| `user_agent` | TEXT | NULL | Client user agent (for device tracking) |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Session creation timestamp |

**Indexes**:
- `idx_sessions_user_id` (user_id) - Find all sessions for a user
- `idx_sessions_expires_at` (expires_at) - Find expired sessions for cleanup
- `idx_sessions_user_expires` (user_id, expires_at) - Find valid sessions for a user (composite)

**Foreign Keys**:
- `user_id → users(id)` with `ON DELETE CASCADE` - Deleting a user deletes all their sessions

**Session Lifecycle**:
1. **Create**: Generate random ID with Oslo, set expiration (default 30 days)
2. **Validate**: Check `expires_at > NOW()` before accepting session
3. **Refresh**: Update `expires_at` to extend session (sliding expiration)
4. **Delete**: Remove on logout or when expired
5. **Cleanup**: Periodic job to delete expired sessions (query: `WHERE expires_at < NOW()`)

---

### 3. email_verification_tokens

**Purpose**: Tokens for email verification flow. Used when users register or change their email.

**Columns**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `token` | TEXT | PRIMARY KEY | Random verification token (generated by Oslo) |
| `user_id` | UUID | REFERENCES users(id) ON DELETE CASCADE | User requesting verification |
| `email` | TEXT | NOT NULL | Email being verified (may differ from user.email) |
| `expires_at` | TIMESTAMPTZ | NOT NULL | Token expiration (typically 24 hours) |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Token creation timestamp |

**Indexes**:
- `idx_email_verification_user_id` (user_id) - Find all tokens for a user
- `idx_email_verification_expires_at` (expires_at) - Find expired tokens for cleanup

**Foreign Keys**:
- `user_id → users(id)` with `ON DELETE CASCADE` - Deleting a user deletes their tokens

**Verification Flow**:
1. **Request**: User registers or requests email change
2. **Generate**: Create token with 24-hour expiration, store email being verified
3. **Send**: Email token link to user (e.g., `/verify-email?token=...`)
4. **Verify**: User clicks link, validate token and expiration
5. **Confirm**: Set `users.email_verified = TRUE`, delete token
6. **Cleanup**: Periodic job to delete expired tokens

**Email Change Flow**:
The `email` column may differ from `users.email` during email change:
- User requests email change to `new@example.com`
- Token stores `email = 'new@example.com'`
- On verification, update `users.email` to token's email

---

### 4. password_reset_tokens

**Purpose**: Tokens for secure password reset flow. Short-lived for security.

**Columns**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `token` | TEXT | PRIMARY KEY | Random reset token (generated by Oslo) |
| `user_id` | UUID | REFERENCES users(id) ON DELETE CASCADE | User requesting reset |
| `expires_at` | TIMESTAMPTZ | NOT NULL | Token expiration (typically 1 hour) |
| `created_at` | TIMESTAMPTZ | DEFAULT NOW() | Token creation timestamp |

**Indexes**:
- `idx_password_reset_user_id` (user_id) - Find all tokens for a user
- `idx_password_reset_expires_at` (expires_at) - Find expired tokens for cleanup

**Foreign Keys**:
- `user_id → users(id)` with `ON DELETE CASCADE` - Deleting a user deletes their tokens

**Password Reset Flow**:
1. **Request**: User submits "forgot password" form with email
2. **Generate**: Create token with 1-hour expiration (short for security)
3. **Invalidate Old**: Delete any existing reset tokens for this user
4. **Send**: Email token link to user (e.g., `/reset-password?token=...`)
5. **Reset**: User clicks link, enters new password, validates token
6. **Confirm**: Hash new password, update `users.password_hash`, delete token
7. **Cleanup**: Periodic job to delete expired tokens

**Security Considerations**:
- Short expiration (1 hour) limits attack window
- Single-use tokens (deleted after use)
- Invalidate old tokens when new one is requested
- Rate limit reset requests to prevent abuse

---

## Index Strategy

### Primary Indexes

All tables have primary key indexes automatically created:
- `users(id)` - UUID lookup
- `sessions(id)` - Session ID lookup
- `email_verification_tokens(token)` - Token lookup
- `password_reset_tokens(token)` - Token lookup

### Secondary Indexes

**Optimized for common query patterns**:

1. **User Lookup**:
   - `idx_users_email` - Login by email (most common operation)
   - Partial indexes for OAuth IDs (only index non-NULL values to save space)

2. **Session Queries**:
   - `idx_sessions_user_id` - List all user sessions (security view)
   - `idx_sessions_expires_at` - Cleanup expired sessions
   - `idx_sessions_user_expires` - Composite index for "find valid session for user" query

3. **Token Cleanup**:
   - Expiration indexes on all token tables for efficient cleanup queries

### Index Rationale

**Why partial indexes for OAuth IDs?**
```sql
CREATE INDEX idx_users_github_id ON users(github_id) WHERE github_id IS NOT NULL;
```
- Only ~20% of users may use GitHub OAuth
- Partial index is 5x smaller and faster
- NULL values don't need indexing

**Why composite index on sessions?**
```sql
CREATE INDEX idx_sessions_user_expires ON sessions(user_id, expires_at);
```
- Common query: "Get valid sessions for user X"
- Single index covers both WHERE conditions
- Faster than using two separate indexes

---

## Foreign Key Cascade Behavior

All child tables use `ON DELETE CASCADE`:

```sql
sessions.user_id → users(id) ON DELETE CASCADE
email_verification_tokens.user_id → users(id) ON DELETE CASCADE
password_reset_tokens.user_id → users(id) ON DELETE CASCADE
```

**Impact**:
- Deleting a user automatically deletes all related data
- Ensures no orphaned sessions or tokens
- Simplifies cleanup logic

**Trade-off**: Cannot "soft delete" users without handling cascades. If soft deletes are needed, consider:
- Adding `deleted_at` column to users table
- Filtering queries to exclude deleted users
- Keeping foreign keys for data integrity

---

## Data Types

### UUID vs TEXT for IDs

**UUIDs (users.id)**:
- Pros: Globally unique, non-sequential (security), standard
- Cons: 16 bytes storage, slightly slower than integers
- Use case: User IDs exposed in URLs and APIs

**TEXT (session/token IDs)**:
- Pros: Flexible length, generated by Oslo (cryptographically secure)
- Cons: Variable storage size
- Use case: Opaque tokens, not exposed as integers

### TIMESTAMPTZ (Timezone-Aware Timestamps)

All timestamps use `TIMESTAMPTZ`:
- Stores UTC time internally
- Returns time in session timezone
- Essential for global applications
- Avoids DST and timezone conversion issues

---

## Migration Files

See `/migrations/` directory:

| File | Purpose |
|------|---------|
| `001_create_users_table.sql` | Create users table |
| `002_create_sessions_table.sql` | Create sessions table |
| `003_create_verification_tokens.sql` | Create email_verification_tokens table |
| `004_create_reset_tokens.sql` | Create password_reset_tokens table |
| `rollback_001.sql` | Drop users table |
| `rollback_002.sql` | Drop sessions table |
| `rollback_003.sql` | Drop email_verification_tokens table |
| `rollback_004.sql` | Drop password_reset_tokens table |
| `README.md` | Migration instructions |

---

## TypeScript Types

See `/src/database/schema.ts` for Kysely type definitions:

```typescript
import type { Database } from './database/schema'

// Type-safe query
const user = await db
  .selectFrom('users')
  .select(['id', 'email', 'name'])
  .where('email', '=', 'user@example.com')
  .executeTakeFirst()
```

**Available Types**:
- `Database` - Complete schema
- `User`, `Session`, `EmailVerificationToken`, `PasswordResetToken` - Row types
- `NewUser`, `NewSession`, etc. - Insert types
- `UserUpdate`, `SessionUpdate`, etc. - Update types
- `PublicUser` - Safe user profile for client exposure

---

## Query Examples

### User Authentication

**Email/Password Login**:
```sql
SELECT id, email, password_hash, email_verified
FROM users
WHERE email = $1;
-- Then verify password_hash with bcrypt
```

**OAuth Login (GitHub)**:
```sql
SELECT id, email, name, avatar_url
FROM users
WHERE github_id = $1;
```

**Create OAuth User**:
```sql
INSERT INTO users (email, github_id, name, avatar_url, email_verified)
VALUES ($1, $2, $3, $4, TRUE)
ON CONFLICT (github_id) DO UPDATE
  SET email = EXCLUDED.email,
      name = EXCLUDED.name,
      avatar_url = EXCLUDED.avatar_url
RETURNING id, email, name;
```

### Session Management

**Create Session**:
```sql
INSERT INTO sessions (id, user_id, expires_at, ip_address, user_agent)
VALUES ($1, $2, NOW() + INTERVAL '30 days', $3, $4)
RETURNING *;
```

**Validate Session**:
```sql
SELECT s.*, u.id, u.email, u.name, u.email_verified
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.id = $1 AND s.expires_at > NOW();
```

**Refresh Session (Sliding Expiration)**:
```sql
UPDATE sessions
SET expires_at = NOW() + INTERVAL '30 days'
WHERE id = $1
RETURNING *;
```

**Delete User Sessions (Logout All Devices)**:
```sql
DELETE FROM sessions
WHERE user_id = $1;
```

### Token Management

**Create Email Verification Token**:
```sql
INSERT INTO email_verification_tokens (token, user_id, email, expires_at)
VALUES ($1, $2, $3, NOW() + INTERVAL '24 hours')
RETURNING *;
```

**Verify Email**:
```sql
-- Validate token
SELECT user_id, email
FROM email_verification_tokens
WHERE token = $1 AND expires_at > NOW();

-- Update user
UPDATE users
SET email_verified = TRUE,
    email = $2  -- If email change
WHERE id = $3;

-- Delete token
DELETE FROM email_verification_tokens
WHERE token = $1;
```

**Create Password Reset Token**:
```sql
-- Delete old tokens
DELETE FROM password_reset_tokens
WHERE user_id = $1;

-- Create new token
INSERT INTO password_reset_tokens (token, user_id, expires_at)
VALUES ($2, $1, NOW() + INTERVAL '1 hour')
RETURNING *;
```

### Cleanup Queries

**Delete Expired Sessions**:
```sql
DELETE FROM sessions
WHERE expires_at < NOW();
```

**Delete Expired Verification Tokens**:
```sql
DELETE FROM email_verification_tokens
WHERE expires_at < NOW();
```

**Delete Expired Reset Tokens**:
```sql
DELETE FROM password_reset_tokens
WHERE expires_at < NOW();
```

---

## Security Considerations

### Password Storage

- Never store plaintext passwords
- Use bcrypt with cost factor 10-12
- `password_hash` column is NULL for OAuth-only users

### Token Generation

- Use cryptographically secure random tokens (Oslo library)
- Token length: 32+ bytes for session IDs, 16+ bytes for verification tokens
- Never use sequential or guessable IDs

### Session Security

- Set reasonable expiration times (30 days default)
- Implement sliding expiration for active users
- Store IP address and user agent for security monitoring
- Allow users to view and revoke sessions

### Rate Limiting

Implement rate limiting for:
- Login attempts (5 per minute per IP)
- Password reset requests (3 per hour per user)
- Email verification requests (5 per hour per user)

### SQL Injection Prevention

- Always use parameterized queries
- Never concatenate user input into SQL
- Kysely provides automatic query parameterization

---

## Performance Considerations

### Expected Query Volumes

| Query Type | Frequency | Optimization |
|------------|-----------|--------------|
| Session validation | Very High | Composite index on (user_id, expires_at) |
| Email login | High | Index on email |
| OAuth login | Medium | Partial indexes on github_id, google_id |
| Token cleanup | Low (batch) | Indexes on expires_at |

### Scaling Strategies

**Vertical Scaling** (recommended for <100k users):
- PostgreSQL handles millions of rows efficiently
- Indexes keep queries under 10ms
- Connection pooling via PgBouncer

**Horizontal Scaling** (for >1M users):
- Read replicas for session validation
- Separate session storage (Redis) if needed
- Keep user/token data in PostgreSQL for ACID guarantees

### Index Maintenance

PostgreSQL automatically maintains indexes, but:
- Monitor index bloat (use `pg_stat_user_indexes`)
- Reindex if necessary (`REINDEX INDEX idx_name`)
- Vacuum regularly (`VACUUM ANALYZE`)

---

## Monitoring

### Key Metrics

```sql
-- Table sizes
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- Index usage
SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;

-- Expired sessions count
SELECT COUNT(*) FROM sessions WHERE expires_at < NOW();

-- Active users (30 days)
SELECT COUNT(DISTINCT user_id)
FROM sessions
WHERE created_at > NOW() - INTERVAL '30 days';
```

---

## Backup and Recovery

### Backup Strategy

```bash
# Full database backup
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d).sql

# Table-specific backup
pg_dump $DATABASE_URL -t users > users_backup.sql

# Restore
psql $DATABASE_URL < backup_20251211.sql
```

### Point-in-Time Recovery

If your PostgreSQL provider supports PITR (Neon, Supabase):
- Enable automatic backups
- Set retention period (7-30 days)
- Test restore procedures regularly

---

## See Also

- `/migrations/README.md` - Migration instructions
- `/src/database/schema.ts` - TypeScript types
- `/REFACTOR_PLAN.md` - Project architecture overview
- [Kysely Documentation](https://kysely.dev/)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
